

from bdb import Breakpoint
from cgitb import text
from cmath import rect
from code import InteractiveInterpreter
from msilib.schema import SelfReg
from operator import truediv
from pyclbr import Class
from sqlite3 import SQLITE_WARNING_AUTOINDEX
import time
from turtle import Screen, back, up
from typing import Self
import pygame
import sys
from pygame.display import flip
from pygame.locals import *
from pygame.sprite import collide_mask
import random
import tkinter as tk
from tkinter import CENTER, messagebox
import pickle
import json
import os
import heapq
import collections

from pygame.time import set_timer


# Definir colores
NEGRO = (0, 0, 0)
BLANCO = (255, 255, 255)
VERDE = (0, 255, 0)
ROJO = (255, 0, 0)
AZUL = (0, 0, 255)
GRIS = (128, 128, 128)  # Nuevo color para el boton desactivado
AMARILLO = (250, 200, 0)

# Definir algunas constantes
SCREEN_WIDTH = 500
SCREEN_HEIGHT = 500
SPRITE_SIZE = 32
SPRITE_SCALE = 10  # Escala del sprite (200%)
SPRITE_SHEET = "huevonaranja.png"
FPS = 30

# Inicializar Pygame
pygame.init()


# Cargar la sprite sheet
sprite_sheet = pygame.image.load(SPRITE_SHEET)

# Obtener los cuadros de la sprite sheet y escalarlos
frames = []
for y in range(0, sprite_sheet.get_height(), SPRITE_SIZE):
    for x in range(0, sprite_sheet.get_width(), SPRITE_SIZE):
        frame = sprite_sheet.subsurface(pygame.Rect(x, y, SPRITE_SIZE, SPRITE_SIZE))
        frame = pygame.transform.scale(frame, (SPRITE_SIZE * SPRITE_SCALE, SPRITE_SIZE * SPRITE_SCALE))
        frames.append(frame)

# Configurar la pantalla
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Note Pet")

# Establecer el reloj para controlar la velocidad de la animación de los sprites
sprite_clock = pygame.time.Clock()

# Establecer el reloj para controlar la lógica del juego
game_clock = pygame.time.Clock()

# Clase para manejar la mascota virtual
class Mascota(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = frames[0]  # Seleccionar el primer frame como imagen inicial
        self.rect = self.image.get_rect()
        self.rect.center = (250, 250)
        self.hambre = 101
        self.vida = 101
        self.muerto = False
        self.tiempo_muerto = None
        self.frame_index = 0 # Indicador del frame actual
        self.frame_start = 0  # Frame de inicio en la sprite sheet
        self.frame_end = 3  # Frame de finalización en la sprite sheet
        self.sprite_time_elapsed = 0  # Tiempo transcurrido para actualizar el sprite
        self.experiencia = 0
        self.nivel = 1  # Nivel inicial
        self.mensaje = Mensaje("")
        self.evoluciones = (1,2,3,4,5)
        self.frames_evolucion = [(0, 3), (4, 7), (8, 11), (12,15), (16,19)]  # Por ejemplo, cada evolución cambia cada 4 frames
        self.evolucion_actual = 0
        self.coins = 0
        
    def subir_nivel(self):
       if self.experiencia >= 100:  # Verificar si la experiencia alcanzó o superó 100
         niveles_subidos = self.experiencia // 100  # Calcular cuántos niveles se han subido
         self.nivel += niveles_subidos  # Sumar el número de niveles subidos al nivel actual
         self.experiencia %= 100  # Modificar la experiencia para que sea el resto después de subir de nivel
         self.coins += niveles_subidos * 5  # Ajusta este valor según lo que consideres apropiado
         print(f"Felicidades, has subido {niveles_subidos} niveles.")
         print(f"Has conseguido el nivel {self.nivel}")
         print(f"Has ganado {niveles_subidos * 5} coins.")
         print(f"Experiencia total de la mascota: {self.experiencia}")
         


    def update(self, dt):
        # Actualizar el tiempo transcurrido para el sprite
        self.sprite_time_elapsed += dt
        if self.nivel == self.evoluciones[self.evolucion_actual]:
            # Cambiar los frames de acuerdo a la siguiente evolución
            self.frame_start, self.frame_end = self.frames_evolucion[self.evolucion_actual]
            self.frame_index = self.frame_start
            self.evolucion_actual += 1  # Moverse a la siguiente evolución
        if self.evolucion_actual >= len(self.evoluciones):
                self.evolucion_actual = len(self.evoluciones) -1  # Mantener la última evolución
                       
                 
        # Actualizar la imagen de la mascota con el nuevo conjunto de frames
        # Cambiar de frame cada 1 segundos
        if  self.sprite_time_elapsed >= 1:
         self.frame_index = (self.frame_index + 1) % (self.frame_end - self.frame_start + 1) + self.frame_start
         self.image = frames[self.frame_index]  # Asignar el nuevo frame como imagen de la mascota
         self.sprite_time_elapsed = 0  # Reiniciar el tiempo transcurrido para el sprite

            
             #Clase para dar mensajes
class Mensaje:
    def __init__(self, texto):
        self.texto = texto
        self.visible = True
        self.font = pygame.font.SysFont("Consolas", 14)  # Fuente para el mensaje
        self.tiempo_visible = 0  # Tiempo transcurrido con el mensaje visible
        self.duracion_maxima = 3  # Duración máxima del mensaje en segundos

    def mostrar(self, pantalla, x, y):
        if self.visible:
            texto_surface = self.font.render(self.texto, True, BLANCO)  # Renderizar el texto
            pantalla.blit(texto_surface, (10, 390))  # Mostrar el texto en la pantalla

    def actualizar(self, dt):
        if self.visible:
            self.tiempo_visible += dt
            if self.tiempo_visible >= self.duracion_maxima:
                self.visible = False
                self.tiempo_visible = 0

    def mostrar_mensaje(self, texto):
        self.texto = texto
        self.visible = True
        self.tiempo_visible = 0  # Reiniciar el tiempo visible

        # Función para alimentar a la mascota
def alimentar_mascota(mascota):
    mascota.hambre += 1 #1
    mascota.vida += .2  #.2
    if mascota.hambre > 101:
        mascota.hambre = 101
    if mascota.vida > 101:
        mascota.vida = 101
    mascota.mensaje = Mensaje("Rico taco")
 
    

# Clase para manejar el registro de texto
class Registro:
    def __init__(self):
        self.texto_ingresado = ""

    def ingresar_texto(self):
        pygame.display.set_caption("Notas de Mascota")
        pantalla_registro = pygame.display.set_mode((500, 500))
        fuente = pygame.font.SysFont("Consolas", 24)
        ingresando = True
        self.texto_ingresado = ""  # Borrar el texto ingresado anteriormente al abrir la pantalla
        sonidoopen.play()

        while ingresando:
            dt = game_clock.tick(FPS) / 10000.0  # Control del tiempo del juego
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    ingresando = False
                    pygame.display.set_caption("Note Pet")
                    pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_RETURN:
                        ingresando = False
                        pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                        pygame.display.set_caption("Note Pet")
                    elif evento.key == pygame.K_BACKSPACE:
                        self.texto_ingresado = self.texto_ingresado[:-1]
                        pantalla_registro.fill(NEGRO)  # Limpiar la pantalla antes de volver a dibujar el texto
                        texto_superficie = fuente.render(self.texto_ingresado, True, BLANCO)
                        pantalla_registro.blit(texto_superficie, (10, 10))  # Mostrar el texto actualizado
                        pygame.display.flip()  # Actualizar la pantalla
                    elif evento.key == pygame.K_TAB:
                        self.texto_ingresado += '\n'  # Agregar un salto de línea al texto ingresado
                    else:
                        self.texto_ingresado += evento.unicode
                        pantalla_registro.fill(NEGRO)  # Limpiar la pantalla antes de volver a dibujar el texto
                        texto_superficie = fuente.render(self.texto_ingresado, True, BLANCO)
                        pantalla_registro.blit(texto_superficie, (10, 10))  # Mostrar el texto actualizado
                        pygame.display.flip()  # Actualizar la pantalla
                        
                       # Dividir el texto en líneas
            lineas = [self.texto_ingresado[i:i+30] for i in range(0, len(self.texto_ingresado), 30)]
            # Renderizar y mostrar cada línea
            for i, linea in enumerate(lineas):
                texto_superficie = fuente.render(linea, True, BLANCO)
                pantalla_registro.blit(texto_superficie, (10, 10 + i * 24))  # Ajustar la posicion vertical
            pygame.display.flip()
                                           
          # Guardar texto en un archivo de texto
        with open("registro_mascota.txt", "a") as archivo:
            archivo.write(self.texto_ingresado + "\n")
                    #Activar reloj principal  
            
dt = game_clock.tick(FPS) / 1000.0  # Convertir a segundos 

# Inicializar mascota
mascota = Mascota()
# Inicializar el objeto de Granja


# Inicializar fuente para mostrar el nivel de hambre y vida
fuente = pygame.font.SysFont("Consolas", 24)
##Clase para iniciar la tienda##

    
class Shop:
    def __init__(self,mascota):
        self.productos = {
            "zanahoria": {"cantidad": 1, "precio": 2 , "efecto": { "vida": 2, "hambre": 2, "experiencia": 2,} , "plantar": True , "tiempo_plantacion": 5  , "imagen": pygame.image.load("zanahoria.png")},
            "naranja": {"cantidad": 1, "precio": 4 , "efecto": { "vida": 1, "hambre": 1, "experiencia": 5,} , "plantar": True , "tiempo_plantacion": 4 , "imagen": pygame.image.load("naranja.png")},
            "papa": {"cantidad": 1, "precio": 5, "efecto": { "vida": 4, "hambre": 3, "experiencia": 4,} , "plantar": True ,  "tiempo_plantacion": 2 ,"imagen": pygame.image.load("papa.png")},
            "muslito": {"cantidad": 1, "precio": 10 , "efecto": { "vida": 5, "hambre": 5, "experiencia": 12,} ,"plantar": False , "imagen": pygame.image.load("muslito.png")},
            "vaca": {"cantidad": 1, "precio": 1000, "efecto": { "vida": 20, "hambre": 11, "experiencia": 40,} , "plantar": True ,  "tiempo_plantacion": 9 ,"imagen": pygame.image.load("vaca.png")},
            "leche": {"cantidad": 1, "precio": 100, "efecto": { "vida": 3, "hambre": 10, "experiencia": 10,} , "plantar": False , "imagen": pygame.image.load("leche.png")},
            "pollo": {"cantidad": 1, "precio": 500, "efecto": { "vida": 10, "hambre": 30, "experiencia": 30,} , "plantar": True ,  "tiempo_plantacion": 7 ,"imagen": pygame.image.load("pollo.png")},
            "huevo": {"cantidad": 1, "precio": 40, "efecto": { "vida": 4, "hambre": 8, "experiencia": 12,} , "plantar": False , "imagen": pygame.image.load("egg.png")},
            "sushi": {"cantidad": 1, "precio": 100, "efecto": { "vida": 6, "hambre": 9, "experiencia": 0,} , "plantar": False , "imagen": pygame.image.load("sushi.png")},
            "sopa": {"cantidad": 1, "precio": 200, "efecto": { "vida": 7, "hambre": 33 , "experiencia": 80,} , "plantar": False , "imagen": pygame.image.load("sopa.png")}, 
            "arbol": {"cantidad": 1, "precio": 20, "efecto": { "vida": 0, "hambre": 0 , "experiencia": 5,} , "plantar": True ,  "tiempo_plantacion": 12 , "imagen": pygame.image.load("arbol.png")}, 
            "madera": {"cantidad": 1, "precio": 15, "efecto": { "vida": 0, "hambre": -8 , "experiencia": 2,} , "plantar": False , "imagen": pygame.image.load("madera.png")}, 
        }
        for producto in self.productos.values():
            producto['rect'] = producto['imagen'].get_rect() 
            
        self.recetas = {
            "sopa": {"ingredientes": {"zanahoria": 3, "papa": 5, "huevo": 4}, "tiempo_elaboracion": 5, "imagen": pygame.image.load("sopa.png")},
            "muslito": {"ingredientes": {"pollo": 1}, "tiempo_elaboracion": 1, "imagen": pygame.image.load("muslito.png")},
            
        }

        

        self.inventario = {}  # Inventario del jugador
        self.mascota = mascota  # Referencia a la mascota
        self.comercio_imagen = pygame.image.load("comercio.png")  # Agregar imagen del comerciante
        self.inventario_imagen = pygame.image.load("inventario.png") #Agrega la imagen para ver inventario
        self.craftear_imagen = pygame.image.load("craftear.png")
       # Variables para el scrollbar
        self.scrollbar_width = 20
        self.scrollbar_color = (150, 150, 150)
        self.scrollbar_handle_color = (100, 100, 100)
        self.scrollbar_handle_height = 50
        self.scrollbar_y = 0  # Posición vertical del scrollbar
        self.visible_product_count = 5  # Cantidad de productos visibles en la pantalla
        self.product_height = 60  # Altura de cada producto
        self.product_rects = {}
        
        # Atributo para controlar el arrastre del scrollbar
        self.dragging = False
       
    def puede_plantar(self, producto_nombre):
        if producto_nombre in self.productos:
            return self.productos[producto_nombre]["plantar"]
        else:
            pass
        
    def dibujar_scrollbar(self, screen):
        # Dibujar el scrollbar
        scrollbar_rect = pygame.Rect(480 - self.scrollbar_width, 0, self.scrollbar_width, 480)
        pygame.draw.rect(screen, self.scrollbar_color, scrollbar_rect)
        
        # Calcular la posición del mango del scrollbar
        handle_y = (self.scrollbar_y / (len(self.productos) * self.product_height - self.visible_product_count * self.product_height)) * (480- self.scrollbar_handle_height)
        handle_rect = pygame.Rect(480 - self.scrollbar_width, handle_y, self.scrollbar_width, self.scrollbar_handle_height)
        pygame.draw.rect(screen, self.scrollbar_handle_color, handle_rect)
      
        
    

    def dibujar_productos(self, screen):
        # Calcular la cantidad de productos visibles en la pantalla
        product_count = len(self.productos)
        visible_product_count = max(product_count, screen.get_height() // self.product_height)
        
        # Calcular la posición de inicio y fin de los productos visibles
        start_index = self.scrollbar_y // self.product_height
        end_index = max(start_index + visible_product_count, product_count)

        # Dibujar solo los productos visibles
        boton_posicion = (1, 1)
        for index, (nombre, producto) in enumerate(list(self.productos.items())[start_index:end_index], start=start_index):
            producto_imagen = producto["imagen"]
            producto_rect = producto_imagen.get_rect(topleft=boton_posicion)
            producto["rect"] = producto_rect  # Guardar el rectángulo en el diccionario del producto
            screen.blit(producto_imagen, producto_rect)
            texto_producto = fuente.render(f"{nombre} - {producto['precio']} coins", True, BLANCO)
            screen.blit(texto_producto, (producto_rect.x, producto_rect.y + 40))
            boton_posicion = (boton_posicion[0], boton_posicion[1] + self.product_height)

            self.dibujar_scrollbar(screen)
            # Almacenar el rectángulo en el diccionario de rectángulos de productos
            self.product_rects[nombre] = producto_rect
           
          
            
        ##Monedas##
        monedas_imagen = pygame.image.load("monedas.png")
        monedas_x = 255  # Coordenada x de las monedas
        monedas_y = 460 # Coordenada y de las monedas
        screen.blit(monedas_imagen, (monedas_x, monedas_y))
    
        # Mostrar cantidad de monedas de la mascota
        texto_monedas = fuente.render(f"coins: {mascota.coins}", True, AMARILLO)
        screen.blit(texto_monedas, (monedas_x + 37, monedas_y + 6))
        
        # Dibujar botón de inventario
        inventario_rect = self.inventario_imagen.get_rect(topleft=(420, 10))
        screen.blit(self.inventario_imagen, inventario_rect)   

        # Dibujar botón de comercio
        comercio_rect = self.comercio_imagen.get_rect(topleft=(420, 50))
        screen.blit(self.comercio_imagen, comercio_rect)
        
        # Dibujar botón de crafteo
        craftear_rect = self.craftear_imagen.get_rect(topleft=(420, 90))
        screen.blit(self.craftear_imagen, craftear_rect)
        
        return comercio_rect, inventario_rect , craftear_rect  # Devolver el rectángulo del botón de comercio
        
        
       
   
    def comprar_producto(self, nombre):
        if nombre in self.productos:
            producto = self.productos[nombre]
            if self.mascota.coins >= producto["precio"]:
                # Restar el precio del producto de las monedas de la mascota
                self.mascota.coins -= producto["precio"]
                # Agregar el producto al inventario de la mascota
                if nombre in self.inventario:
                    self.inventario[nombre] += 1
                else:
                    self.inventario[nombre] = 1
                print(f"Has comprado {nombre}")
                print(f"Monedas restantes de la mascota: {self.mascota.coins}")
           
        else:
                print("No tienes suficientes monedas")
                print(self.inventario)
    
    def comerciar(self,):
        # Obtener un producto aleatorio del inventario
        if self.inventario:
            producto_aleatorio = random.choice(list(self.inventario.keys()))
            cantidad_producto = self.inventario[producto_aleatorio]
            # Obtener monedas al vender el producto (aquí puedes ajustar cómo se calculan las monedas)
            monedas_obtenidas = random.randint(1, 4) * cantidad_producto
            # Actualizar el inventario y las monedas del jugador
            del self.inventario[producto_aleatorio] # Eliminar el producto del inventario
            self.mascota.coins += monedas_obtenidas  # Agregar las monedas al jugador
            print(f"Has vendido {cantidad_producto} {producto_aleatorio} por {monedas_obtenidas} coins.")
        else:
            print("No tienes productos para comerciar.")
    


    def craftear_receta(self, nombre_receta):
        if nombre_receta in self.recetas:
            receta = self.recetas[nombre_receta]
            ingredientes = receta["ingredientes"]
            puede_craftear = True

            # Verificar si el jugador tiene suficientes ingredientes
            for ingrediente, cantidad in ingredientes.items():
                if ingrediente not in self.inventario or self.inventario[ingrediente] < cantidad:
                    puede_craftear = False
                    print(f"No tienes suficientes ingredientes para craftear {nombre_receta}.")
                    break

            # Si tiene suficientes ingredientes, craftear la receta
            if puede_craftear:
                for ingrediente, cantidad in ingredientes.items():
                    self.inventario[ingrediente] -= cantidad  # Restar los ingredientes del inventario
                    if self.inventario[ingrediente] == 0:
                        del self.inventario[ingrediente]  # Eliminar el ingrediente si se ha agotado
            
                # Agregar la receta crafteada al inventario
                if nombre_receta in self.inventario:
                    if nombre_receta == "muslito":
                        self.inventario[nombre_receta] += 2  # Agregar 2 unidades de "muslito" al inventario
                    else:
                        self.inventario[nombre_receta] += 1  # Agregar 1 unidad de la receta al inventario
                else:
                    if nombre_receta == "muslito":
                        self.inventario[nombre_receta] = 2  # Agregar 2 unidades de "muslito" al inventario
                    else:
                        self.inventario[nombre_receta] = 1  # Agregar 1 unidad de la receta al inventario

                print(f"Has crafteado {nombre_receta}.")
        else:
            print(f"No existe la receta {nombre_receta}.")


    
    def abrir_crafteo(self):
        pygame.display.set_caption("Crafteos")
        pantalla_crafteos = pygame.display.set_mode((480, 480))
        ingresando_crafteos = True
    
        while ingresando_crafteos:
            dt = game_clock.tick(FPS) / 10000.0  # Control del tiempo del juego
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    ingresando_crafteos = False
                    pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                    pygame.display.set_caption("Tienda de Mascota")
                elif evento.type == pygame.MOUSEBUTTONDOWN:
                    if evento.button == 1:  # Boton izquierdo del raton
                        # Verificar si se hizo clic en una receta y craftearla si es posible
                        for nombre, ingredientes in self.recetas.items():
                            receta_imagen = self.recetas[nombre]["imagen"]
                            receta_rect = receta_imagen.get_rect(topleft=(1, 80 * list(self.recetas.keys()).index(nombre) + 1))
                            if receta_rect.collidepoint(evento.pos):
                                self.craftear_receta(nombre)  # Llamar a la función de craftear receta
                                break
            # Ajustar tamaño de la fuente
            tamano_fuente = 20
            fuente = pygame.font.SysFont("consolas", tamano_fuente)

            # Limpiar la pantalla
            pantalla_crafteos.fill(NEGRO)

            # Dibujar las recetas de crafteo
            boton_posicion = (1, 1)
            for nombre, ingredientes in self.recetas.items():
                receta_imagen = self.recetas[nombre]["imagen"]
                receta_rect = receta_imagen.get_rect(topleft=boton_posicion)
                pantalla_crafteos.blit(receta_imagen, receta_rect)

                # Crear el texto del nombre de la receta
                texto_nombre = fuente.render(nombre, True, BLANCO)
                pantalla_crafteos.blit(texto_nombre, (receta_rect.x + 45, receta_rect.y + 0))

                # Crear el texto de los ingredientes
                texto_ingredientes = "ingredientes: "
                for ingrediente, cantidad in ingredientes["ingredientes"].items():
                    texto_ingredientes += f"{ingrediente}:{cantidad}, "

                # Renderizar el texto de los ingredientes
                texto_superficie = fuente.render(texto_ingredientes, True, BLANCO)
                pantalla_crafteos.blit(texto_superficie, (receta_rect.x + 5, receta_rect.y + tamano_fuente + 15))

                boton_posicion = (boton_posicion[0], boton_posicion[1] + 80)

            pygame.display.flip()
    def dibujar_inventario(self, screen):
        # Calcular la cantidad de productos visibles en la pantalla
        product_count = len(self.inventario)
        visible_product_count = max(product_count, screen.get_height() // 5)

        # Calcular la posición de inicio y fin de los productos visibles
        start_index = self.scrollbar_y // self.product_height
        end_index = min(start_index + visible_product_count, product_count)

        # Dibujar solo los productos visibles
        boton_posicion = (1, 1)
        for index, (nombre, cantidad) in enumerate(list(self.inventario.items())[start_index:end_index]):
            producto_imagen = self.productos[nombre]["imagen"]
            producto_rect = producto_imagen.get_rect(topleft=(boton_posicion[0], boton_posicion[1]))
            screen.blit(producto_imagen, producto_rect)
            texto_cantidad = fuente.render(f"   x   {cantidad}", True, BLANCO)
            screen.blit(texto_cantidad, (producto_rect.x + 5, producto_rect.y + 5))

            # Actualizar el rect del producto en el diccionario
            self.product_rects[nombre] = producto_rect

            # Ajustar la posición vertical para el próximo producto
            boton_posicion = (boton_posicion[0], boton_posicion[1] + 50)

        self.dibujar_scrollbar(screen)
       
         # Método para actualizar el scroll
    
      
          
            
    def abrir_inventario(self):
        pygame.display.set_caption("Inventario de la Mascota")
        pantalla_inventario = pygame.display.set_mode((480, 480))
        ingresando_inventario = True
        producto_seleccionado = None  # Almacenar el nombre del producto seleccionado
                
                    

        while ingresando_inventario:
            dt = game_clock.tick(FPS) / 10000.0  # Control del tiempo del juego
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    ingresando_inventario = False
                    pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                    pygame.display.set_caption("Tienda de Mascota")
                elif evento.type == pygame.MOUSEBUTTONDOWN:
                    if evento.button == 3:  # Boton derecho del raton
                        # Verificar si se hizo clic en un producto y seleccionarlo
                     for nombre, cantidad in self.inventario.items():
                        producto_imagen = self.productos[nombre]["imagen"]
                        producto_rect = producto_imagen.get_rect(topleft=(1, 50 * list(self.inventario.keys()).index(nombre) + 1))
                        if producto_rect.collidepoint(evento.pos):
                            producto_seleccionado = nombre
                            print(f"{producto_seleccionado},se uso en la granja.")
                            ingresando_inventario = False
                            break     
                if evento.type == pygame.MOUSEBUTTONDOWN:
                 if evento.button == 1:  # Boton izquierdo del raton   
                # Verificar si aún quedan productos en el inventario
                   if any(cantidad > 0 for cantidad in self.inventario.values()):
                    # Verificar si se hizo clic en un producto y seleccionarlo
                     for nombre, cantidad in self.inventario.items():
                        producto_imagen = self.productos[nombre]["imagen"]
                        producto_rect = producto_imagen.get_rect(topleft=(1, 50 * list(self.inventario.keys()).index(nombre) + 1))
                        if producto_rect.collidepoint(evento.pos):
                          if nombre in self.inventario:
                            if self.inventario[nombre] > 0:  # Verificar si la cantidad es mayor que cero
                                self.inventario[nombre] -= 1
                                producto_seleccionado = nombre
                                efecto_producto = self.productos[nombre]["efecto"]  # Acceder al efecto del producto específico
                                for atributo, valor in efecto_producto.items():
                                    setattr(self.mascota, atributo, getattr(self.mascota, atributo) + valor)
                                print(f"has utilizado: {producto_seleccionado}")    
                                print(f"La mascota ahora tiene Vida: {self.mascota.vida}, Hambre: {self.mascota.hambre}, Experiencia: {self.mascota.experiencia}")
                                mascota.subir_nivel()
                            else:
                                print("No tienes suficiente cantidad de este producto en el inventario")
                                break
                          

                    
                                   
               
                 elif evento.button == 5:  # Rueda del ratón hacia arriba
                      self.scrollbar_y += 70  # Ajusta la velocidad del scroll como prefieras
                 elif evento.button == 4:  # Rueda del ratón hacia abajo
                      self.scrollbar_y -= 70  # Ajusta la velocidad del scroll como prefieras
                      
                 max_scroll = max(0, len(self.inventario) * 50 - (480))
                 self.scrollbar_y = min(max_scroll, (480))
                
            pantalla_inventario.fill(NEGRO)       
            self.dibujar_inventario(pantalla_inventario)
            mascota.update(dt)

            pygame.display.flip() 
            
        return producto_seleccionado
        
    def ingresar_shop(self):
        pygame.display.set_caption("Tienda de Mascota")
        pantalla_shop = pygame.display.set_mode((500, 500))
        ingresando_shop = True

       
        while ingresando_shop:
            dt = game_clock.tick(FPS) / 10000.0  # Control del tiempo del juego
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    ingresando_shop = False
                    pygame.display.set_mode(
                        (SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                    pygame.display.set_caption("Note Pet")
                elif evento.type == pygame.MOUSEBUTTONDOWN:
                    if evento.button == 1:  # Boton izquierdo del raton
                        # Verificar si se hizo clic en un producto y comprarlo
                        for nombre, producto in self.productos.items():
                            if producto["rect"].collidepoint(evento.pos):
                                self.comprar_producto(nombre)
                        # Verificar si se hizo clic en el botón de comercio
                        comercio_rect, inventario_rect , craftear_rect = self.dibujar_productos(pantalla_shop)
                        if comercio_rect.collidepoint(evento.pos):
                            self.comerciar()
                        # Verificar si se hizo clic en el boton de inventario
                        if inventario_rect.collidepoint(evento.pos):
                            self.abrir_inventario()
                            mascota.subir_nivel()
                             # Verificar si se hizo clic en el boton de inventario
                        if craftear_rect.collidepoint(evento.pos):
                            self.abrir_crafteo()
                            mascota.subir_nivel()
           
                    elif evento.button == 5:  # Rueda del ratón hacia arriba
                               self.scrollbar_y += 70  # Ajusta la velocidad del scroll como prefieras
                    elif evento.button == 4:  # Rueda del ratón hacia abajo
                               self.scrollbar_y -= 70  # Ajusta la velocidad del scroll como prefieras
            
            
                    # Limitar la posición del scrollbar para que no se salga de los límites
                    max_scroll = len(self.productos) * self.product_height - self.visible_product_count * self.product_height
                    self.scrollbar_y = max(0, min(self.scrollbar_y, max_scroll))
                   
                                   
          
           
          

            pantalla_shop.fill(NEGRO)
            comercio_rect, inventario_rect , craftear_rect = self.dibujar_productos(pantalla_shop)  # Dibujar los productos en la tienda
            self.dibujar_productos(pantalla_shop)  # Dibujar los productos en la tienda
            pygame.display.flip()
            

                            
             
   
    
#inicializar la clase shop
   
shop = Shop(mascota)  



class Granja(Shop):
    TILE_SIZE = 32
    NUM_TILES = 15
    PLANT_GROW_TIME = 20  # Tiempo de crecimiento en segundos
    CLOCK_TICK = 1000  # Intervalo de tiempo del reloj en milisegundos

    READY_TO_PLANT = 0
    PLANTED = 1
    GROWING = 2
  
    def __init__(self, mascota, registro_granja):
        super().__init__(mascota)
        self.planted_products = {}  # Diccionario para mapear las posiciones de los cultivos a los nombres de los productos plantados
        self.growth_finished = set()   # Conjunto para almacenar posiciones de tiles con crecimiento finalizado
        self.clock = pygame.time.Clock()  # Reloj global
        self.registro_granja = registro_granja  # Guarda el nombre del archivo
        self.planting_time = {} #registro de plantación
        pygame.init()
        self.tile_images = {}  # Diccionario para mapear las posiciones de los Tiles a las imágenes de los productos
        self.load_product_images()  # Cargar las imágenes de los productos
        self.tile_colors = [[(0, 0, 0) for _ in range(self.NUM_TILES)] for _ in range(self.NUM_TILES)]
        self.tile_states = {(x, y): Granja.READY_TO_PLANT for x in range(self.NUM_TILES) for y in range(self.NUM_TILES)}
        
    def load_product_images(self):
                                                                         # Cargar las imágenes de los productos
        for producto in self.productos:
            imagen_path = self.productos[producto]["imagen"]
            self.tile_images[producto] = imagen_path
     
    def start_growth_timer(self, tile_position, timer_id=None):
        if timer_id is None:
            timer_id = pygame.USEREVENT + tile_position[0] * self.NUM_TILES + tile_position[1]
            pygame.time.set_timer(timer_id, self.PLANT_GROW_TIME * 1000)
            self.planting_time[tile_position] = pygame.time.get_ticks()  # Guardar el tiempo actual como tiempo de plantación

    def stop_growth_timer(self, tile_position):
        timer_id = pygame.USEREVENT + tile_position[0] * self.NUM_TILES + tile_position[1]
        pygame.time.set_timer(timer_id, 0)   
            
    def update(self):
                                               # Actualizar el estado de los cultivos en función del tiempo transcurrido
        for tile_position, state in self.tile_states.items():
              if state == Granja.GROWING:
                  self.tile_states[tile_position] = Granja.READY_TO_PLANT
                  if tile_position in self.planted_products:
                        self.growth_finished.add(tile_position)
        
    
    def guardar_datos(self):
        # Guardar información sobre los productos plantados y sus tiempos de plantación
        with open(self.registro_granja, 'w') as file:
            for position, product in self.planted_products.items():
                planting_time = self.planting_time.get(position, 0)  # Obtener el tiempo de plantación o 0 si no está definido
                file.write(f"{position[0]},{position[1]},{product},{planting_time}\n")
  
        # Guardar información sobre los tiles con crecimiento finalizado
        with open("growth_finished_data.txt", "w") as archivo:
            for position in self.growth_finished:
                archivo.write(f"{position[0]},{position[1]}\n")
             
    def cargar_datos(self):
        # Cargar información sobre los productos plantados y sus tiempos de plantación
        with open(self.registro_granja, 'r') as file:
            for line in file:
                parts = line.strip().split(',')
                x = int(parts[0])
                y = int(parts[1])
                product = parts[2]
                planting_time = float(parts[3])
                self.planted_products[(x, y)] = product
                if planting_time > 0:
                    # Calcular el tiempo que ha pasado desde la plantación
                    elapsed_time = (pygame.time.get_ticks() - planting_time) / 1000
                    # Calcular el tiempo restante hasta que el producto crezca completamente
                    remaining_time = max(0, self.PLANT_GROW_TIME - elapsed_time)
                    # Iniciar el temporizador con el tiempo restante
                    self.start_growth_timer((x, y))
       
        # Cargar información sobre los tiles con crecimiento finalizado
        with open("growth_finished_data.txt", "r") as archivo:
            for line in archivo:
                parts = line.strip().split(',')
                x = int(parts[0])
                y = int(parts[1])
                self.growth_finished.add((x, y))


                                                          #Posición del mouse
    
    def get_tile_at_mouse_pos(self, mouse_pos):
        x, y = mouse_pos
        tile_x = x // self.TILE_SIZE
        tile_y = y // self.TILE_SIZE
        return (tile_x, tile_y)
                                                                         #Plantar#
    def plant_product(self, producto_nombre, tile_position):
        # Verificar si se puede plantar el producto
        if producto_nombre in self.productos and self.productos[producto_nombre]["plantar"]:
            if producto_nombre in shop.inventario and shop.inventario[producto_nombre] > 0:
                if self.tile_states[tile_position] == Granja.READY_TO_PLANT:
                    if shop.puede_plantar(producto_nombre):
                        self.planted_products[tile_position] = producto_nombre
                        self.tile_states[tile_position] = Granja.PLANTED
                        shop.inventario[producto_nombre] -= 1
                        print(f"{producto_nombre} plantado en la posicion {tile_position}")
                        self.planting_time[tile_position] = time.time()
                        tiempo_plantacion = self.productos[producto_nombre]["tiempo_plantacion"]
                        # Calcular el tiempo de crecimiento en milisegundos
                        pygame.time.set_timer(pygame.USEREVENT + tile_position[0] * self.NUM_TILES + tile_position[1], tiempo_plantacion * 10000)

                        return True
                    else:
                        print("Este producto no se puede plantar en la granja.")
                        return False
                else:
                    print("El tile no esta listo para plantar.")
                    return False
            else:
                print("No tienes suficientes productos para plantar.")
                return False
        else:
            print("No se puede plantar este producto.")
            return False
            pygame.display.flip()
                                                                                            #recolectar#
    def collect_product(self, tile_position):
     if tile_position in self.planted_products:
        if tile_position in self.growth_finished:
            producto_nombre = self.planted_products.pop(tile_position)
            if producto_nombre == "vaca":
                # Primero, agrega una vaca al inventario
                if "vaca" not in shop.inventario:
                    shop.inventario["vaca"] = 1
                shop.inventario["vaca"] += 1
                print("Recolectado una vaca.")
                # Luego, cambia el nombre del producto recolectado a "leche"
                producto_nombre = "leche"
            if producto_nombre == "pollo":
                # Primero, agrega un pollo al inventario
                if "pollo" not in shop.inventario:
                    shop.inventario["pollo"] = 1
                shop.inventario["pollo"] += 1
                print("Recolectado una pollo.")
                # Luego, cambia el nombre del producto recolectado a "huevo"
                producto_nombre = "huevo"
            if producto_nombre == "arbol":
                # Primero, agrega una arbol al inventario
                if "arbol" not in shop.inventario:
                    shop.inventario["arbol"] = 1
                shop.inventario["arbol"] += 1
                print("Recolectado una arbol.")
                # Luego, cambia el nombre del producto recolectado a "madera"
                producto_nombre = "madera"
            if producto_nombre not in shop.inventario:
                shop.inventario[producto_nombre] = 5
            shop.inventario[producto_nombre] += 5
            self.tile_states[tile_position] = Granja.READY_TO_PLANT
            self.tile_colors[tile_position[1]][tile_position[0]] = (20, 20, 0)
            self.growth_finished.remove(tile_position)
            print(f"Recolectado {producto_nombre} de la posicion {tile_position}")
            return True
        else:
            print("El producto aun no ha crecido completamente en esa posicion.")
            return False

            
            pygame.display.flip()
        
          
                    
    def Land(self):
         pygame.display.set_caption("Granja")
         pantalla_Land = pygame.display.set_mode((480, 480))
         self.draw_screen(pantalla_Land)  # Dibujar la pantalla al abrirse
         pygame.display.flip()  # Actualizar la pantalla antes del bucle
         farmeando = True
         tile_clicked = None  # Inicializa tile_clicked aquí
         producto_seleccionado = None  # Inicializa producto_seleccionado aquí
         self.cargar_datos()
               
         while farmeando:
             for evento in pygame.event.get():
                  if evento.type == pygame.QUIT:
                        farmeando = False  # Salir del bucle cuando se cierra la ventana
                        self.guardar_datos()
                        pygame.display.set_mode(
                            (SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                        pygame.display.set_caption("Note Pet")
                  elif evento.type == pygame.MOUSEBUTTONDOWN:
                        mouse_pos = pygame.mouse.get_pos()
                        tile_clicked = self.get_tile_at_mouse_pos(mouse_pos)  # Asigna la posición del tile clickeado
                        print("Clic en tile:", tile_clicked)
                        print(shop.inventario)  # Acceder al inventario de la granja
                        if evento.button == 1:  # Si se hizo clic izquierdo
                           producto_seleccionado = shop.abrir_inventario()  # Obtener el producto seleccionado del inventario
                        if self.plant_product(producto_seleccionado, tile_clicked):
                                # Dibujar nuevamente la pantalla solo si la plantación fue exitosa
                                self.draw_screen(pantalla_Land)
                                pygame.display.flip()  # Actualizar la pantalla después de la plantación
                        elif evento.button == 3:  # Si se hizo clic derecho
                            if tile_clicked in self.planted_products:
                                if self.collect_product(tile_clicked):
                                    # Dibujar nuevamente la pantalla solo si la recolección fue exitosa
                                   self.draw_screen(pantalla_Land)
                                   pygame.display.flip()  # Actualizar la pantalla después de la recolección
                  elif evento.type >= pygame.USEREVENT and evento.type < pygame.USEREVENT + self.NUM_TILES * self.NUM_TILES:
                        # Evento del temporizador de crecimiento
                          timer_key = evento.type - pygame.USEREVENT
                          tile_position = (timer_key // self.NUM_TILES, timer_key % self.NUM_TILES)
                          if tile_position in self.planted_products:
                           self.growth_finished.add(tile_position)
                       

                  self.draw_screen(pantalla_Land)
                  pygame.display.flip()  # Actualizar la pantalla después de que un producto haya terminado de crecer

    def draw_screen(self, screen):
        # Dibujar los colores de fondo de los tiles
        for y in range(self.NUM_TILES):
            for x in range(self.NUM_TILES):
                tile_position = (x, y)
                if tile_position in self.growth_finished:
                    color = (2, 100, 33)  # Verde si el crecimiento ha finalizado
                elif tile_position in self.planted_products:
                    color = (4, 9, 1)  # color si está plantado
                elif self.tile_states[tile_position] == Granja.READY_TO_PLANT:
                    color = (2, 4, 0)  # color si está listo para plantar
                else:
                    color = (20, 25, 20)  # Gris oscuro si no está plantado
                pygame.draw.rect(screen, color, (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE), 0)
                pygame.draw.rect(screen, (20, 40, 0), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE), 1)
                
        
        # Dibujar las imágenes de los productos si están plantados
        for tile_position, producto_nombre in self.planted_products.items():
            image = self.tile_images[producto_nombre]
            screen.blit(image, (tile_position[0] * self.TILE_SIZE, tile_position[1] * self.TILE_SIZE))
                
                 # Dibujar la imagen del producto si está plantado
        if (x, y) in self.planted_products:
            producto_nombre = self.planted_productst[tile_position]
            image = self.tile_images[producto_nombre]
            screen.blit(image, (x * self.TILE_SIZE, y * self.TILE_SIZE))
    
    # Para manejar el temporizador de los cultivos
    def handle_timer_event(self, event):
      timer_key = event.type - pygame.USEREVENT
      tile_position = (timer_key // self.NUM_TILES, timer_key % self.NUM_TILES)
      if tile_position in self.planted_products:
        self.growth_finished.add(tile_position)
        
        pygame.display.flip()  # Actualizar la pantalla después de que un producto haya terminado de crecer

     

 #iniciar la clase granja
granja = Granja(mascota, 'datos_granja.txt')

class Mundo:
    TILE_SIZE = 32
    NUM_TILES = 15
    SCREEN_WIDTH_Mundo = TILE_SIZE * NUM_TILES
    SCREEN_HEIGHT_Mundo = TILE_SIZE * NUM_TILES

    def __init__(self):
        self.jugador_pos = (0, 0)  # Posición inicial del jugador
        self.oponente_pos = (14, 0)  # Posición inicial del oponente
        self.meta_pos = (0, 14)  # Meta del jugador
        self.meta_oponente = (14, 14)  # Meta del oponente
        self.obstaculos = []  # Lista para almacenar las posiciones de los obstáculos
        self.turno_jugador = True
        self.dx = 0  # Desplazamiento en x
        self.dy = 0  # Desplazamiento en y
        self.obstaculos_colocados = 0  # Obstáculos colocados en el turno actual
        self.obstaculos_colocados_ia = 0  # Obstáculos colocados por la IA

   
    def distancia_manhattan(self,pos1, pos2):
        return abs(mundo.oponente_pos[0] - mundo.jugador_pos[0]) + abs(mundo.meta_oponente[1] - mundo.meta_pos[1])


    def random_position_with_distance(self, target_pos, distance):
        while True:
            x = random.randint(0, self.NUM_TILES - 1)
            y = random.randint(0, self.NUM_TILES - 1)
            if (self.distancia_manhattan((x, y), target_pos) == distance and
                (x, y) not in self.obstaculos):
                return (x, y)

    def bfs(self, start, goal):
        # Implementación simplificada de BFS para verificar si hay una ruta
        queue = [(start, [start])]
        visited = set()

        while queue:
            (current, path) = queue.pop(0)
            if current in visited:
                continue
            visited.add(current)
            for neighbor in self.get_neighbors(current):
                if neighbor == goal:
                    return path + [goal]
                elif neighbor not in visited:
                    queue.append((neighbor, path + [neighbor]))
        return None

    def get_neighbors(self, pos):
        # Obtener vecinos válidos (dentro de los límites y no en obstáculos)
        x, y = pos
        neighbors = [(x + dx, y + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]]
        valid_neighbors = [n for n in neighbors if 0 <= n[0] < self.NUM_TILES and 0 <= n[1] < self.NUM_TILES and n not in self.obstaculos]
        return valid_neighbors

    def reset_positions(self):
        while True:
            distancia_jugador_meta = self.distancia_manhattan(self.jugador_pos, self.meta_pos)
            distancia_oponente_meta = self.distancia_manhattan(self.oponente_pos, self.meta_oponente)

            # Borrar solo el 30% de los obstáculos
            obstaculos_a_borrar = random.sample(self.obstaculos, int(len(self.obstaculos) * 0.3))
            for obstaculo in obstaculos_a_borrar:
                self.obstaculos.remove(obstaculo)

            while True:
                nueva_pos_jugador = self.random_position_with_distance(self.meta_pos, distancia_jugador_meta)
                nueva_pos_oponente = self.random_position_with_distance(self.meta_oponente, distancia_oponente_meta)

                # Asegúrate de que las metas no estén en posiciones de obstáculos
                if (nueva_pos_jugador not in self.obstaculos and
                    nueva_pos_oponente not in self.obstaculos):
                    # Asegúrate de que las metas estén simétricamente ubicadas
                    nueva_meta_pos = (self.NUM_TILES - nueva_pos_jugador[0], self.NUM_TILES - nueva_pos_jugador[1])
                    nueva_meta_oponente = (self.NUM_TILES - nueva_pos_oponente[0], self.NUM_TILES - nueva_pos_oponente[1])

                    # Verificar que las nuevas posiciones no coincidan con las posiciones actuales y los obstáculos
                    if (nueva_pos_jugador != nueva_meta_oponente and
                        nueva_pos_oponente != nueva_meta_pos and
                        nueva_pos_jugador != nueva_pos_oponente and
                        nueva_pos_jugador != self.jugador_pos and
                        nueva_pos_oponente != self.oponente_pos and
                        nueva_meta_pos not in self.obstaculos and
                        nueva_meta_oponente not in self.obstaculos and
                        nueva_meta_pos != nueva_meta_oponente):
                        self.jugador_pos = nueva_pos_jugador
                        self.oponente_pos = nueva_pos_oponente
                        self.meta_pos = nueva_meta_pos
                        self.meta_oponente = nueva_meta_oponente
                        break

            # Verificar si hay rutas válidas para el jugador y el oponente hacia sus metas
            if (self.bfs(self.jugador_pos, self.meta_pos) is not None and
                self.bfs(self.oponente_pos, self.meta_oponente) is not None):
                break

        self.obstaculos_colocados = 0  # Reiniciar el contador de obstáculos del jugador
        self.obstaculos_colocados_ia = 0  # Reiniciar el contador de obstáculos del oponente

    # Método para verificar si se puede colocar un obstáculo sin bloquear todas las rutas
    def puede_colocar_obstaculo(self, pos):
        original_obstaculos = self.obstaculos.copy()
        self.obstaculos.append(pos)

        ruta_jugador = self.bfs(self.jugador_pos, self.meta_pos)
        ruta_oponente = self.bfs(self.oponente_pos, self.meta_oponente)

        self.obstaculos = original_obstaculos  # Restaurar los obstáculos originales

        return ruta_jugador is not None and ruta_oponente is not None
    
    def get_tile_at_mouse_pos(self, mouse_pos):
        x, y = mouse_pos
        tile_x = x // self.TILE_SIZE
        tile_y = y // self.TILE_SIZE
        return (tile_x, tile_y)

    def check_win(self):
        if self.jugador_pos == self.meta_pos:
            self.show_message("El jugador ha ganado!")
            return True
        elif self.oponente_pos == self.meta_oponente:
            self.show_message("El oponente ha ganado!")
            return True
        return False

    def show_message(self, message):
        root = tk.Tk()
        root.withdraw()
        messagebox.showinfo("Fin del juego", message)
        root.destroy()

    def bfs(self, inicio, meta):
        queue = collections.deque([inicio])
        visited = set()
        padres = {}

        while queue:
            current_node = queue.popleft()
            if current_node == meta:
                return self.reconstruir_camino(inicio, meta, padres)

            for neighbor in self.get_neighbors(current_node):
                if (neighbor not in visited and
                    neighbor not in self.obstaculos):  # Verificar si el vecino no es un obstáculo
                    queue.append(neighbor)
                    visited.add(neighbor)
                    padres[neighbor] = current_node

        return None

    def get_neighbors(self, pos):
        x, y = pos
        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]
        return [(nx, ny) for nx, ny in neighbors if 0 <= nx < self.NUM_TILES and 0 <= ny < self.NUM_TILES]

    def reconstruir_camino(self, inicio, meta, padres):
        camino = []
        actual = meta
        while actual != inicio:
            camino.append(actual)
            actual = padres[actual]
        camino.append(inicio)
        return camino[::-1]
    
    def mover_oponente(self):
        # Usar BFS para encontrar un camino desde la posición actual del oponente hasta la meta
        camino = self.bfs(self.oponente_pos, self.meta_oponente)

        # Si se encuentra un camino, seguirlo
        if camino and len(camino) > 1:
            # El primer elemento en el camino es la posición actual, el segundo es la siguiente posición
            siguiente_posicion = camino[1]

            # Verificar si la siguiente posición está bloqueada por un obstáculo
            if siguiente_posicion not in self.obstaculos:
                self.oponente_pos = siguiente_posicion
            else:
                print("La siguiente bloque 3")

                # Si la siguiente posición está bloqueada, buscar un vecino que no esté bloqueado
                for neighbor in self.get_neighbors(self.oponente_pos):
                    if neighbor not in self.obstaculos:
                        self.oponente_pos = neighbor
                        break
        else:
            # Calcular la dirección hacia la meta si no se encuentra un camino con BFS
            dx, dy = 0, 0
            if self.oponente_pos[0] < self.meta_oponente[0]:
                dx = 1
            elif self.oponente_pos[0] > self.meta_oponente[0]:
                dx = -1
            if self.oponente_pos[1] < self.meta_oponente[1]:
                dy = 1
            elif self.oponente_pos[1] > self.meta_oponente[1]:
                dy = -1

            # Nueva posición propuesta
            new_x = self.oponente_pos[0] + dx
            new_y = self.oponente_pos[1] + dy

            # Si la nueva posición no está bloqueada, mover el oponente
            if (new_x, new_y) not in self.obstaculos:
                self.oponente_pos = (new_x, new_y)
            else:
                print("La nueva pos obstaculo 4")

    def turno(self):
        if self.turno_jugador:
            self.obstaculos_colocados = 0
            self.manejar_eventos()  # Escucha eventos del jugador
            self.mover_jugador()
            self.dibujar_jugador()
            self.dibujar_meta()
        else:
            self.colocar_obstaculos_oponente()
            self.mover_oponente()
            self.dibujar_jugador()
            self.dibujar_meta()
            self.turno_jugador = True  # Cambiar de turno al jugador
    
    def dibujar_tablero(self):
        for y in range(self.NUM_TILES):
            for x in range(self.NUM_TILES):
                pygame.draw.rect(self.pantalla, (0, 0, 0), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE), 1)
                if (x, y) == self.jugador_pos:
                    pygame.draw.rect(self.pantalla, (255, 255, 255), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
                elif (x, y) == self.oponente_pos:
                    pygame.draw.rect(self.pantalla, (255, 0, 0), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
                elif (x, y) == self.meta_pos:
                    pygame.draw.rect(self.pantalla, (0, 255, 0), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
                elif (x, y) == self.meta_oponente:
                    pygame.draw.rect(self.pantalla, (200, 50, 255), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
                elif (x, y) in self.obstaculos:
                    pygame.draw.rect(self.pantalla, (0, 0, 255), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
                    
    def dibujar_jugador(self):
        for y in range(self.NUM_TILES):
            for x in range(self.NUM_TILES):
                if (x, y) == self.jugador_pos:
                    pygame.draw.rect(self.pantalla, (255, 255, 255), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
                
    
    def dibujar_meta(self):
        for y in range(self.NUM_TILES):
            for x in range(self.NUM_TILES):
                if (x, y) == self.meta_pos:
                    pygame.draw.rect(self.pantalla, (0, 255, 0), (x * self.TILE_SIZE, y * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE))
    
    def manejar_eventos(self):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                mundero = False
                pygame.display.set_caption("Note Pet")
                pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  # Restaurar tamaño original de la ventana
                registro.ingresar_texto()
                quit()
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_UP:
                    self.dx, self.dy = 0, -1  # Mover hacia arriba
                elif evento.key == pygame.K_DOWN:
                    self.dx, self.dy = 0, 1  # Mover hacia abajo
                elif evento.key == pygame.K_LEFT:
                    self.dx, self.dy = -1, 0  # Mover hacia la izquierda
                elif evento.key == pygame.K_RIGHT:
                    self.dx, self.dy = 1, 0  # Mover hacia la derecha
            elif evento.type == pygame.KEYUP:
                if evento.key in (pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT, pygame.K_RIGHT):
                    self.dx, self.dy = 0, 0  # Detener movimiento
            elif evento.type == pygame.MOUSEBUTTONDOWN and self.turno_jugador:
                if evento.button == 1:  # Botón izquierdo del mouse
                    mouse_pos = pygame.mouse.get_pos()
                    tile_clicked = self.get_tile_at_mouse_pos(mouse_pos)
                    if tile_clicked not in [self.jugador_pos, self.meta_pos, self.meta_oponente, self.oponente_pos] and tile_clicked not in self.obstaculos and self.obstaculos_colocados < 5:
                        self.obstaculos.append(tile_clicked)
                        self.obstaculos_colocados += 1  # Incrementar el contador de obstáculos del turno
                        if self.obstaculos_colocados >= 1:
                            self.turno_jugador = False  # Cambiar el turno al oponente después de colocar 3 obstáculos

    def mover_jugador(self):
        new_x = self.jugador_pos[0] + self.dx
        new_y = self.jugador_pos[1] + self.dy
    
        # Verificar si la nueva posición está dentro del tablero y no es un obstáculo
        if (0 <= new_x < self.NUM_TILES and
            0 <= new_y < self.NUM_TILES and
            (new_x, new_y) not in self.obstaculos and
            abs(self.dx) + abs(self.dy) == 1):  # Movimiento válido de solo una casilla
            self.jugador_pos = (new_x, new_y)
            self.dx, self.dy = 0, 0  # Reiniciar el desplazamiento
            self.turno_jugador = False
            
    def colocar_obstaculos_oponente(self):
        count = 0
        while count < 1:
            x = random.randint(0, self.NUM_TILES - 1)
            y = random.randint(0, self.NUM_TILES - 1)
            if (x, y) not in [self.jugador_pos, self.meta_pos, self.meta_oponente, self.oponente_pos] and (x, y) not in self.obstaculos:
                self.obstaculos.append((x, y))
                count += 1
                
    def Okalux(self):
        pygame.display.set_caption("Okalux")
        self.pantalla = pygame.display.set_mode((self.SCREEN_WIDTH_Mundo, self.SCREEN_HEIGHT_Mundo))
        pygame.display.flip()
        mundero = True
    
        while mundero:
            self.manejar_eventos()  # Manejar eventos del teclado
            self.mover_jugador()  # Mover al jugador

            if not self.turno_jugador:
                self.turno()  # Ejecutar la lógica del turno para el oponente
                self.dibujar_tablero()  # Dibujar el tablero después de que el oponente ha movido
                pygame.display.flip()

            self.pantalla.fill((0, 0, 0))  # Limpiar pantalla antes de redibujar
            self.dibujar_tablero()  # Dibujar el tablero con los elementos actuales
            pygame.display.flip()
            if self.check_win():
                 self.reset_positions()
                 
               
           
                
            
            


# Crear una instancia de Mundo y llamar al método Okalux
mundo = Mundo()

# Crear una instancia de Mundo y llamar al método Okalux




granja.cargar_datos()

dt = game_clock.tick(FPS) / 1000.0  # Convertir a segundos 
        # Actualizar la mascota
mascota.update(dt)
# Inicializar botón de alimentar
boton_alimentar = pygame.Rect(450, 80, 140, 40)
###
#Inicializar boton de combate
boton_granja = pygame.Rect(450,80,140, 40)
#Inicializar boton de mundo
boton_mundo = pygame.Rect(450,80,140, 40)

# Inicializar el objeto de registro de texto
registro = Registro()
# Iniciaalizar el objetode tienda de mascota

shop = Shop(mascota)



# Inicializar el tiempo transcurrido

time_elapsed = 0

# Variable para controlar si se debe bloquear el botón de alimentar
bloquear_boton_alimentar = False
# Variable para controlar si se debe bloquear el boton de granja
bloquear_boton_granja = False
# Variable para controlar si se debe bloquear el boton de mundo
bloquear_boton_mundo = False

#sonidos##

sonidoopen =pygame.mixer.Sound("open.mp3")

# Función para cargar datos al iniciar el juego
def cargar_datos():
    try:
        with open("save.pet.txt", "r") as archivo:
            # Leer las primeras 9 posiciones para los valores de la mascota
            datos_mascota = archivo.readline().strip().split(',')
            mascota.hambre = float(datos_mascota[0])
            mascota.vida = float(datos_mascota[1])
            mascota.experiencia = int(datos_mascota[2])
            mascota.nivel = int(datos_mascota[3])
            mascota.evolucion_actual = int(datos_mascota[4])
            mascota.frame_index = int(datos_mascota[5])
            mascota.frame_start = int(datos_mascota[6])
            mascota.frame_end = int(datos_mascota[7])
            mascota.coins = int(datos_mascota[8])
                       
    except FileNotFoundError:
        # Manejar el caso cuando el archivo no existe
        pass

def cargar_inventario():
    try:
        with open("inventory.txt", "r") as archivo:
            for linea in archivo:
                nombre, cantidad = linea.strip().split(',')
                shop.inventario[nombre] = int(cantidad)
    except FileNotFoundError:
        # Manejar el caso cuando el archivo no existe
        pass

    
       
# Llamada a la función para cargar datos al iniciar el juego
cargar_datos()

############ llamar funcion cargar inventario###
cargar_inventario()


# Bucle principal del juego
running = True
while running:
    # Manejo de eventos
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:  # Botón izquierdo del ratón
                if not mascota.muerto and not bloquear_boton_alimentar and boton_alimentar.collidepoint(event.pos):
                    alimentar_mascota(mascota)
                elif not mascota.muerto:
                    mascota.experiencia += 1  # Incrementar experiencia al hacer clic
                    print(f"Has ganado 1 punto de experiencia Total de experiencia: {mascota.experiencia}")
                    mascota.subir_nivel()  # Verificar si se puede subir de nivel
                if not mascota.muerto and not bloquear_boton_granja and boton_granja.collidepoint(event.pos):
                    granja.Land()
                if not mascota.muerto and not bloquear_boton_granja and boton_mundo.collidepoint(event.pos):
                    mundo.Okalux()
            elif event.button == 3:  # Botón derecho del ratón
                if not mascota.muerto:
                    registro.ingresar_texto()
            elif event.button == 2:  # Botón central del ratón
                if not mascota.muerto:
                    shop.ingresar_shop()  
              # Manejo de eventos del temporizador
        elif event.type >= pygame.USEREVENT and event.type < pygame.USEREVENT + granja.NUM_TILES * granja.NUM_TILES:
            # Llama a la función que maneja los eventos del temporizador
            granja.handle_timer_event(event)
        
    
                

    # Calcular el tiempo transcurrido desde el último fotograma
    dt = game_clock.tick(FPS) / 1000.0  # Se fijan los FPS a 30
    time_elapsed += dt
    # Calcular el nivel actual
    nivel_actual = mascota.nivel + int(mascota.experiencia / 100)

    # Actualizar la vida y el hambre
    if not mascota.muerto:
        mascota.hambre -= dt * .1 # Reducir el hambre con el tiempo .1
        mascota.vida -= dt * .06  # Reducir la vida con el tiempo     .06

        # Restringir los valores de hambre y vida entre 0 y 100
        mascota.hambre = max(0, min(101, mascota.hambre))
        mascota.vida = max(0, min(101, mascota.vida))

        # Lógica para abrir la ventana de texto cada 10 minutos
        if time_elapsed > 600:
            registro.ingresar_texto()
            time_elapsed = 0  # Reiniciar el tiempo transcurrido

        # Actualizar la mascota
        mascota.update(dt)
        # Actualizar el mensaje
        mascota.mensaje.actualizar(dt)
    else:
        # Si la mascota está muerta, bloquear el botón de alimentar durante 2 minutos
        if mascota.tiempo_muerto is None:
            mascota.tiempo_muerto = pygame.time.get_ticks()  # Marcar el tiempo de muerte

        tiempo_actual = pygame.time.get_ticks()
        tiempo_transcurrido = tiempo_actual - mascota.tiempo_muerto

        if tiempo_transcurrido > 120000:  # 3600 segundos = 4 minutos
            bloquear_boton_alimentar = False
            bloquear_boton_granja = False
            bloquear_boton_mundo = False
            mascota.tiempo_muerto = None
            mascota.muerto = False
            mascota.hambre = 20
            mascota.vida = 50
            mascota.nivel = 0
            mascota.experiencia = 0
            mascota.frame_index = 0
            mascota.frame_start = 0
            mascota.frame_end = 3
            mascota.evolucion_actual = 0
            mascota.coins = 0
            mascota.frames_evolucion = 0,3
            shop.inventario = {}
            pygame.display.flip()
            
        else:
            bloquear_boton_alimentar = True


            
        # Actualizar la mascota
        mascota.update(dt)
        # Actualizar el mensaje
        mascota.mensaje.actualizar(dt)
    # Revisar si la mascota ha muerto debido a hambre y vida cero
    if mascota.hambre <= 0 and mascota.vida <= 0:
        mascota.muerto = True
        bloquear_boton_alimentar = True
        bloquear_boton_granja = True
        bloquear_boton_alimentar = True

    # Dibujar la pantalla
    screen.fill(NEGRO)

    # Dibujar la mascota
    screen.blit(mascota.image, mascota.rect)

    # Dibujar barra de hambre
    barra_hambre_ancho = max(mascota.hambre, 0) * 3  # Asegurarse de que la anchura nunca sea negativa
    pygame.draw.rect(screen, VERDE, (10, 10, barra_hambre_ancho, 20))
    pygame.draw.rect(screen, BLANCO, (10, 10, 3, 20), 2)
    texto_hambre = fuente.render(f"Hambre: {int(max(mascota.hambre, 0))}", True, BLANCO)
    screen.blit(texto_hambre, (330, 10))

    # Dibujar barra de vida
    barra_vida_ancho = max(mascota.vida, 0) * 3  # Asegurarse de que la anchura nunca sea negativa
    pygame.draw.rect(screen, ROJO, (10, 40, barra_vida_ancho, 20))
    pygame.draw.rect(screen, BLANCO, (10, 40, 3, 20), 2)
    texto_vida = fuente.render(f"Vida: {int(max(mascota.vida, 0))}", True, BLANCO)
    screen.blit(texto_vida, (330, 40))

    # Dibujar barra de experiencia
    barra_experiencia_ancho = max(mascota.experiencia, 0) * 4.7  # Asegurarse de que la anchura nunca sea negativa
    pygame.draw.rect(screen, AZUL, (10, 470, barra_experiencia_ancho, 20))
    pygame.draw.rect(screen, AZUL, (10, 470, 1, 20), 2)
    texto_experiencia = fuente.render(f"Experiencia: {int(mascota.experiencia)}", True, BLANCO)
    screen.blit(texto_experiencia, (10, 470))
    screen.blit(texto_experiencia, (10, 470))
    
    # Mostrar el nivel actual en la barra de experiencia
    texto_nivel = fuente.render(f"Nivel: {nivel_actual}", True, BLANCO)
    screen.blit(texto_nivel, (360, 470))

    # Dibujar botón de alimentar centrado en la parte inferior de la pantalla
    boton_alimentar.x = (SCREEN_WIDTH - boton_alimentar.width) // 2
    boton_alimentar.y = SCREEN_HEIGHT - 80  # Ajustar la posición vertical
    pygame.draw.rect(screen, BLANCO if not bloquear_boton_alimentar else GRIS, boton_alimentar)  # Cambiar el color si está bloqueado

    # Definir el texto del botón según el estado de la mascota
    if mascota.muerto:
        texto_boton = fuente.render("Muerto", True, NEGRO)
    elif bloquear_boton_alimentar:
        texto_boton = fuente.render("Bloqueado", True, ROJO)
    else:
        texto_boton = fuente.render("Alimentar", True, NEGRO)

    # Mostrar el texto del botón
    screen.blit(texto_boton, (boton_alimentar.x + 10, boton_alimentar.y + 10))

    # Dibujar botón de granja a la izquierda en la parte inferior de la pantalla
    boton_granja.x = (SCREEN_WIDTH - boton_alimentar.width) // 12
    boton_granja.y = SCREEN_HEIGHT - 80  # Ajustar la posición vertical
    pygame.draw.rect(screen, BLANCO if not bloquear_boton_alimentar else GRIS, boton_granja)  # Cambiar el color si está bloqueado
    
    
      # Definir el texto del botón según el estado de la mascota
    if mascota.muerto:
        texto_boton = fuente.render("Muerto", True, NEGRO)
    elif bloquear_boton_granja:
        texto_boton = fuente.render("Bloqueado", True, ROJO)
    else:
        texto_boton = fuente.render("Granja", True, NEGRO)
    
    ##
    screen.blit(texto_boton, (boton_granja.x + 20, boton_granja.y + 10))
    
     # Dibujar botón de mundo a la derecha en la parte inferior de la pantalla
    boton_mundo.x = (SCREEN_WIDTH + boton_alimentar.width) // 1.935
    boton_mundo.y = SCREEN_HEIGHT - 80  # Ajustar la posición vertical
    pygame.draw.rect(screen, BLANCO if not bloquear_boton_alimentar else GRIS, boton_mundo)  # Cambiar el color si está bloqueado
    
    
      # Definir el texto del botón según el estado de la mascota
    if mascota.muerto:
        texto_boton = fuente.render("Muerto", True, NEGRO)
    elif bloquear_boton_granja:
        texto_boton = fuente.render("Bloqueado", True, ROJO)
    else:
        texto_boton = fuente.render("Mundo", True, NEGRO)
    
    ##
    screen.blit(texto_boton, (boton_mundo.x + 33, boton_mundo.y + 10))
    
    

    # Mostrar mensajes
    mascota.mensaje.mostrar(screen, 10, 100)

    # Actualizar la pantalla
    pygame.display.flip()


    # Mostrar mensajes
    mascota.mensaje.mostrar(screen, 10, 100)
    pygame.display.flip()


# Guardar datos antes de cerrar el juego
def guardar_datos():
    with open("save.pet.txt", "w") as archivo:
        archivo.write(f"{mascota.hambre},{mascota.vida},{mascota.experiencia},{mascota.nivel},{mascota.evolucion_actual},{mascota.frame_index},{mascota.frame_start},{mascota.frame_end},{mascota.coins}")
# Guardar datos del inventario
def guardar_inventario():
    with open("inventory.txt", "w") as archivo:
        for nombre, cantidad in shop.inventario.items():
            archivo.write(f"{nombre},{cantidad}\n")

                
# Guardar datos del inventario
guardar_inventario()       
# Guardar datos de la granja
# Llamada a la función para guardar datos antes de cerrar el juego
guardar_datos()
# LLamar al guardado de la granja



# Luego de salir del bucle principal, cerrar Pygame

pygame.quit()
sys.exit()
